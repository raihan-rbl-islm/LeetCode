# 605. Can Place Flowers

**Difficulty:** Easy  
**Topic:** Array, Greedy  
**Link:** [LeetCode 605](https://leetcode.com/problems/can-place-flowers/)

## Intuition

We use a greedy approach to plant flowers in every valid spot. To optimize the process, we use an "optimistic" strategy:
1. Iterate through the flowerbed.
2. If a spot is empty (`0`), we optimistically assume we can plant (`count++`).
3. We immediately check the neighbors (left and right).
   - If a neighbor is occupied (`1`), our assumption was wrong. We undo the count (`count--`).
   - If both neighbors are clear, the placement is valid. We then skip the next index (`i++`) because adjacent plots cannot have flowers.

We also add an optimization to the loop condition (`count < n`) to stop execution immediately once we have planted enough flowers.

## Complexity

* **Time Complexity:** $O(N)$ — In the worst case, we traverse the array once. The early exit condition makes it faster on average.
* **Space Complexity:** $O(1)$ — We use only a few integer variables for state tracking.

## Code (C++)

```cpp
class Solution {
public:
    bool canPlaceFlowers(vector<int>& flowerbed, int n) {
        int count = 0, sz = flowerbed.size();
        
        // Optimization: Stop loop early if we already found enough spots (count < n)
        for (int i = 0; i < sz && count < n; i ++) {
            if (!flowerbed[i]) {
                // Optimistically plant
                count ++;
                
                // Check for conflicts with Right or Left neighbors
                bool conflictRight = (i + 1 < sz && flowerbed[i + 1]);
                bool conflictLeft = (i - 1 >= 0 && flowerbed[i - 1]);
                
                if (conflictRight || conflictLeft) {
                    count --; // Undo if conflict exists
                } else {
                    i ++; // Optimization: Skip next spot since we planted here
                }
            }
        }
        return count >= n;
    }
};
